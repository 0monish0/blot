---
import Layout from '../layouts/Layout.astro'
---

<script>
  import { OBJLoader } from 'three/addons/loaders/OBJLoader.js'
  import { MTLLoader } from 'three/addons/loaders/MTLLoader.js'
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
  import * as THREE from 'three'
  import { turtles } from '../lib/paths.js'
  import { runTextReturnTurtles } from '../lib/runTextReturnTurtles.ts'

  const navHeight = document.querySelector('nav')?.offsetHeight

  let objects = {
    x: [],
    y: []
  }

  // Set up scene
  const scene = new THREE.Scene()
  scene.background = null
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  )
  // Set up renderer
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  })

  // const controls = new OrbitControls(camera, renderer.domElement)

  renderer.setSize(window.innerWidth, window.innerHeight - navHeight)
  renderer.domElement.style.zIndex = '999'
  renderer.domElement.style.top = `${navHeight}px`
  const threeContainer = document.querySelector('.three-js-container')
  threeContainer.appendChild(renderer.domElement)

  // Set up light
  const light = new THREE.DirectionalLight(0xffffff)
  light.position.set(-0.5, 0, 1)
  scene.add(light)

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5)
  scene.add(ambientLight)

  // Add the parts
  const objLoader = new OBJLoader().setPath('/model/')
  const mtlLoader = new MTLLoader().setPath('/model/')

  camera.position.z = 0.4;
  camera.position.x = 0;
  camera.rotation.z = Math.PI;
  camera.position.y = -0.055;



  const toolTip = addSphere({
    radius: 0.005,
    color: "green"
  });


  [
    {
      name: 'feet',
      post: obj => {
        obj.position.z = 0.038
      }
    },
    {
      name: 'carriage',
      post: obj => {
        obj.position.z = 0.063
      }
    },
    {
      name: 'arm',
      post: obj => {
        obj.position.z = 0.065
      }
    },
    {
      name: 'penholder',
      post: obj => {
        obj.position.z = 0.065
      }
    }
  ].map(addObj)

  function addObj({ name, post }) {
    mtlLoader.load(`${name}.mtl`, function (materials) {
      materials.preload()
      objLoader.setMaterials(materials).load(
        `${name}.obj`,
        function (object) {
          scene.add(object)
          objects[name] = object

          const boundingBox = new THREE.Box3().setFromObject(object)
          const yOffset = boundingBox.min.y
          const xOffset = (boundingBox.min.x + boundingBox.max.x) / 2
          const zOffset = (boundingBox.min.z + boundingBox.max.z) / 2

          object.traverse(child => {
            if (child instanceof THREE.Mesh) {
              child.position.set(-xOffset, -yOffset, -zOffset)
            }
          })

          post(object)
        },
        function (xhr) {},
        function (error) {
          console.log(error)
        }
      )
    })
  }

  let texCanvas = document.createElement('canvas')
  // document.body.appendChild(texCanvas);
  texCanvas.style = `
      position: absolute;
      left: 0px;
      top: 0px;
      z-index: 999999;
      scale: .5;
      transform-origin: left top;

    `
  const texCanvasWidth = 512
  const texCanvasHeight = 512 * 2
  texCanvas.width = texCanvasWidth
  texCanvas.height = texCanvasHeight

  let ctx = texCanvas.getContext('2d')

  ctx.fillStyle = 'rgba(255, 255, 255, 0)'
  ctx.fillRect(0, 0, texCanvasWidth, texCanvasHeight)
  // ctx.fillStyle = 'blue';
  // ctx.fillRect(128, 128, 256, 256);

  const testTurtles = runTextReturnTurtles(`
      const t = createTurtle();

      for (let i = 0; i < 300; i++) {
        t.forward(i);
        t.right(91);
      }

      drawTurtles(t);
    `)

  if (testTurtles.length > 1) {
    const [first, ...rest] = testTurtles

    rest.forEach(t => first.join(rest))
  }

  const oneTurtle = testTurtles.length > 0 ? testTurtles[0] : null

  oneTurtle.translate([texCanvasWidth / 2, texCanvasHeight / 2], oneTurtle.cc)

  console.log(oneTurtle)

  ctx.beginPath()
  oneTurtle.path.forEach(p => {
    p.forEach((point, i) => {
      if (i === 0) ctx.moveTo(...point)
      else ctx.lineTo(...point)
    })
  })
  ctx.strokeStyle = 'black'
  ctx.strokeWidth = 2
  ctx.stroke()

  let texture = new THREE.CanvasTexture(texCanvas)
  texture.needsUpdate = true
  texture.minFilter = THREE.LinearFilter

  let geometry = new THREE.PlaneGeometry(0.4, 0.8)
  let material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true
    // opacity: .4
  })

  let plane = new THREE.Mesh(geometry, material)
  plane.position.x = 0
  plane.position.y = 0
  plane.position.z = 0
  scene.add(plane)

  renderer.domElement.addEventListener('mousemove', e => {
    const { x, y } = getRelativePoint(e, threeContainer)
    const point = getIntersectedPoint(x, y, plane)

    if (point) {
      moveMachine(point.x, point.y)
    }
  })

  function dist(x1: number, y1: number, x2: number, y2: number) {
    return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
  }

  const lerp = (x, y, a) => x * (1 - a) + y * a
  const clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a))
  const invlerp = (x, y, a) => clamp((a - x) / (y - x))
  const range = (x1, y1, x2, y2, a) => lerp(x2, y2, invlerp(x1, y1, a))

  function animate() {
    requestAnimationFrame(animate)
    renderer.render(scene, camera)
  }

  animate()

  // Function to handle resizing
  function onResize(entries) {
    const bb = threeContainer.getBoundingClientRect()
    for (let entry of entries) {
      // For simplicity, using window dimensions, but you can use the container's dimensions
      const width = bb.width
      const height = bb.height

      // Update the camera's aspect ratio and projection matrix
      camera.aspect = width / height
      camera.updateProjectionMatrix()

      // Update the renderer's size
      renderer.setSize(width, height)

      // Optional: re-render the scene
      renderer.render(scene, camera)
    }
  }

  const resizeObserver = new ResizeObserver(onResize)
  resizeObserver.observe(threeContainer)

  function addSphere({ radius, color, x, y }) {
    x = x ?? 0;
    y = y ?? 0;

    const sphereRadius = radius
    const sphereWidthSegments = 32 // Number of segmented faces around the circumference of the sphere.
    const sphereHeightSegments = 32 // Number of rows of faces from the sphere's top to bottom.

    const sphereGeometry = new THREE.SphereGeometry(
      sphereRadius,
      sphereWidthSegments,
      sphereHeightSegments
    )

    const sphereMaterial = new THREE.MeshBasicMaterial({ color }) // green color

    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial)
    scene.add(sphereMesh)

    sphereMesh.position.x = x
    sphereMesh.position.y = y

    return sphereMesh
  }

  function getIntersectedPoint(x, y, targetObject) {
    const raycaster = new THREE.Raycaster()
    const mouse = new THREE.Vector2()

    const rect = renderer.domElement.getBoundingClientRect()

    // Update the mouse vector with passed x and y values
    mouse.x = (x / rect.width) * 2 - 1
    mouse.y = -(y / rect.height) * 2 + 1

    // Update the picking ray with the camera and mouse position
    raycaster.setFromCamera(mouse, camera)

    // Calculate objects intersecting the picking ray
    const intersects = raycaster.intersectObject(targetObject)

    if (intersects.length > 0) {
      return intersects[0].point // This is the Vector3 representing the intersection point in 3D space
    } else {
      return null // No intersection
    }
  }

  function getRelativePoint(event, element) {
    const rect = element.getBoundingClientRect()

    return {
      x: event.clientX - rect.left,
      y: event.clientY - rect.top
    }
  }

  function moveMachine(x, y) {
    if (Object.keys(objects).length < 4) return
    console.log(x, y);
    x = Math.max(x, -0.07031505489843565);
    y = Math.max(y, -0.21385993884461388);

    x = Math.min(x, 0.06585060696837623);
    y = Math.min(y, -0.06802130646267329);

    toolTip.position.x = x;
    toolTip.position.y = y;
    toolTip.position.z = 0;

    objects.penholder.position.x = x
    objects.penholder.position.y = y

    objects.carriage.position.x = x
    objects.carriage.position.y = 0.03

    objects.arm.position.x = x + 0.0175
    objects.arm.position.y = y + 0.04
  }
</script>

<style>

  html, body {
    background-image: linear-gradient(to right, #ddd 1px, transparent 1px), linear-gradient(to bottom, #ddd 1px, transparent 1px);
    background-size: 40px 40px;
    font-family: var(--font-sans);
  }

  .header-section {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 70%;
    padding: 1rem;
  }

  .header-text {
    font-size: 2.8rem;
    letter-spacing: -2px;
  }

  .lead-section {
    position: relative;
  }

  .how-to {
    height: 500px;
    background: #ffc9c9;
  }

  .get-started {
    height: 500px;
    background: antiquewhite;
  }

</style>

<Layout title="Blot" description="Blot out the world!">
  <div class="lead-section">
    <div class="header-section header-text">
      <div>Blot, the plotter bot from Hack Club</div>
      <div>Code some art, get a machine.</div>
    </div>
    <div class="three-js-container"></div>
  </div>
  <div class="how-to header-text">
    Here is how to get a machine
  </div>
  <div class="get-started header-text">
    Haven't programmed art before, don't worry you can get started here
  </div>
</Layout>
