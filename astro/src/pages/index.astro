---
import Layout from "../layouts/Layout.astro";
---

<script>
    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
    import * as THREE from "three";
    import { turtles } from "../lib/paths.js";

    const navHeight = document.querySelector("nav")?.offsetHeight;

    let objects = {
        x: [],
        y: []
    };

    // Set up scene
    const scene = new THREE.Scene();
    scene.background = null;
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );

    // Set up renderer
    const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
    });
    renderer.setSize(window.innerWidth, window.innerHeight - navHeight);
    renderer.domElement.style.zIndex = "999";
    document.body.appendChild(renderer.domElement);

    // Set up light
    const light = new THREE.DirectionalLight(0xffffff);
    light.position.set(0.5, 0, 1);
    scene.add(light);

    // Add the parts
    const objLoader = new OBJLoader().setPath("/model/");
    const mtlLoader = new MTLLoader().setPath("/model/");

    camera.position.z = 0.3;
    camera.position.x = -0.2;
    camera.rotation.z = Math.PI;
    camera.position.y = -0.25;

    mtlLoader.load("feet.mtl", function (materials) {
        materials.preload();
        objLoader.setMaterials(materials).load(
            "feet.obj",
            function (object) {
                scene.add(object);
                objects.feet = object;
            },
            function (xhr) {},
            function (error) {
                console.log(error);
            }
        );
    });

    mtlLoader.load("carriage.mtl", function (materials) {
        materials.preload();
        objLoader.setMaterials(materials).load(
            "carriage.obj",
            function (object) {
                scene.add(object);
                objects.carriage = object;
            },
            function (xhr) {},
            function (error) {
                console.log(error);
            }
        );
    });

    mtlLoader.load("arm.mtl", function (materials) {
        materials.preload();
        objLoader.setMaterials(materials).load(
            "arm.obj",
            function (object) {
                scene.add(object);
                objects.arm = object;
            },
            function (xhr) {},
            function (error) {
                console.log(error);
            }
        );
    });

    mtlLoader.load("penholder.mtl", function (materials) {
        materials.preload();
        objLoader.setMaterials(materials).load(
            "penholder.obj",
            function (object) {
                scene.add(object);
                objects.x.push(renderer.domElement.offsetWidth / 2);
                objects.y.push(renderer.domElement.offsetHeight / 2);
                objects.penholder = object;
            },
            function (xhr) {},
            function (error) {
                console.log(error);
            }
        );
    });

    // Set up turtle
    let width, height;
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    ctx.strokeStyle = "black";
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight - navHeight;

    const turtle = turtles[0];
    let polyline = turtle.path[0];
    const config = {
        scale: 5,
        xoff: 70,
        yoff: -10,
        lineStart: 1,
        lineEnd: polyline.length
    };
    const paths = polyline.map(([x, y]) => [
        (x + config.xoff) * config.scale,
        (y + config.yoff) * config.scale
    ]);
    let i = config.lineStart;
    let j = config.lineStart;

    function dist(x1: number, y1: number, x2: number, y2: number) {
        return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
    }

    const lerp = (x, y, a) => x * (1 - a) + y * a;
    const clamp = (a, min = 0, max = 1) => Math.min(max, Math.max(min, a));
    const invlerp = (x, y, a) => clamp((a - x) / (y - x));
    const range = (x1, y1, x2, y2, a) => lerp(x2, y2, invlerp(x1, y1, a));

    function moveTo(x: number, y: number) {
        // let mappedX = range(
        //     0,
        //     width,
        //     -camera.position.z / config.scale,
        //     camera.position.z / config.scale,
        //     x
        // );
        // let xoff = range(
        //     0,
        //     width,
        //     -camera.position.z / config.scale,
        //     camera.position.z / config.scale,
        //     config.xoff
        // );
        // let mappedY = range(
        //     0,
        //     height,
        //     -camera.position.y / config.scale,
        //     camera.position.y / config.scale,
        //     y
        // );
        // let yoff = range(
        //     0,
        //     height,
        //     -camera.position.y / config.scale,
        //     camera.position.y / config.scale,
        //     config.yoff
        // );

        // const vFOV = camera.fov*Math.PI/180;
        // const height = 2 * Math.tan(vFOV/2)*camera.position.z;
        // const width = height * camera.aspect;

        // console.log(camera.fov, x*height, y*width);

        // objects.carriage.position.x = x*width+camera.position.x;
        // objects.arm.position.x = x*width+camera.position.x;
        // objects.penholder.position.x = x*width+camera.position.x;
        // objects.arm.position.y = y*height-camera.position.y;
        // objects.penholder.position.y = y*height-camera.position.y;

        function screenToWorld(x, y, camera) {
            // Convert to NDC (-1 to 1 for x and y)
            const ndcX = (x / window.innerWidth) * 2 - 1;
            const ndcY = -(y / window.innerHeight) * 2 + 1; // negative because y is flipped in screen coordinates

            const nearPlaneZ = camera.near;
            const farPlaneZ = camera.far;

            const worldPos = new THREE.Vector3(ndcX, ndcY, 0.5); // z = 0.5 will map to a point in the middle of your near and far plane
            worldPos.unproject(camera); // This transforms the point from NDC to world space

            return worldPos;
        }

        // const worldPosition = screenToWorld(x, y, camera);

        // objects.carriage.position.set(worldPosition.x, worldPosition.y, 0);
        // objects.arm.position.set(worldPosition.x, worldPosition.y, 0);
        // objects.penholder.position.set(worldPosition.x, worldPosition.y, 0);


         const ndcX = (x / window.innerWidth) * 2 - 1;
        const ndcY = -(y / window.innerHeight) * 2 + 1;

        let mouse = new THREE.Vector2();
        mouse.x = ndcX;
        mouse.y = ndcY;



        let raycaster = new THREE.Raycaster();

        function updateModelPosition() {
            raycaster.setFromCamera(mouse, camera);

            const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            let intersectionPoint = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(planeZ, intersectionPoint);

            console.log(intersectionPoint)

            // x: .057 to -.071
            //

            objects.carriage.position.x = intersectionPoint.x;
            objects.arm.position.x = intersectionPoint.x;
            objects.penholder.position.x = intersectionPoint.x;
            objects.arm.position.y = intersectionPoint.y;
            objects.penholder.position.y = intersectionPoint.y;
            // yourModel.position.z remains the same unless you want to change it
        }

        // updateModelPosition();

        console.log(x, y);

        const mappedX = lerp(.057, -.071, x);

        objects.carriage.position.x = mappedX;
        objects.arm.position.x = mappedX;
        objects.penholder.position.x = mappedX;
        // objects.arm.position.y = intersectionPoint.y;
        // objects.penholder.position.y = intersectionPoint.y;

        objects.x.push(x);
        objects.y.push(y);
    }

    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        if (
            i < config.lineEnd - 1 &&
            objects.arm != undefined &&
            objects.penholder != undefined &&
            objects.carriage != undefined &&
            objects.feet != undefined
        ) {
            i +=
                10 /
                dist(
                    paths[j - 1][0],
                    paths[j - 1][1],
                    paths[j][0],
                    paths[j][1]
                );
            j = Math.floor(i);
            ctx.clearRect(0, 0, width, height);
            let [x, y] = paths[j];
            // increase i a bit if we're out of the screen
            if (x < 0 || x > width || y < 0 || y > height) i++;
            if (j === 0) ctx.moveTo(x, y);
            else
                ctx.lineTo(
                    lerp(paths[j - 1][0], x, i - j),
                    lerp(paths[j - 1][1], y, i - j)
                );
            ctx.stroke();

            // moveTo(x, y);
        }
    }

    animate();

    function moveMachine(x, y) {

    }

    window.addEventListener("mousemove", e => {
        let x = e.clientX/window.innerWidth;
        // console.log(x);
        // if (x < .2+.065) x = 0;
        // else if (x > .8-.065) x = 1;
        // else {
        //     x = (x - (.2+.065))/(.6-.065*2);
        // }

        x = (x - (.2+.065))/(.6-.065*2);

        let y = 1-e.clientY/window.innerHeight;
        // x = x/window.innerWidth
        moveTo(x, y);Â 
    })
</script>

<style is:global lang="scss">
    body,
    html {
        background-size: 40px 40px;
        background-image: linear-gradient(to right, #ddd 1px, transparent 1px),
            linear-gradient(to bottom, #ddd 1px, transparent 1px);
        min-height: 100vh;
    }

    canvas {
        border-bottom: 1px dashed var(--primary);
        position: absolute;
        z-index: 999;
        bottom: 0;
        left: 0;
        height: 100vh;
    }

    h1 {
        font-family: var(--font-sans);
        font-size: 4rem;
        max-width: 50vw;
        margin-inline: 4rem;
        line-height: 1;
        letter-spacing: -2px;

        span {
            color: var(--primary);
        }
    }
</style>

<Layout title="Blot" description="Blot out the world!">
    <canvas id="canvas"></canvas>
    <section></section>
</Layout>
