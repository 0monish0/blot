import { i as createVNode, s as spreadAttributes, F as Fragment } from "./astro.2c740cbe.mjs";
import "html-escaper";
import "cookie";
import "kleur/colors";
import "path-to-regexp";
import "mime";
import "string-width";
const images = {};
function updateImageReferences(html2) {
  return html2.replaceAll(
    /__ASTRO_IMAGE_="([^"]+)"/gm,
    (full, imagePath) => spreadAttributes({ src: images[imagePath].src, ...images[imagePath].attributes })
  );
}
const html = updateImageReferences('<h3 id="henry-bass-beginnerintermediate-20min">(Henry Bass, Beginner/Intermediate, 20min)</h3>\n<p><a href="https://en.wikipedia.org/wiki/Elementary_cellular_automaton">Elementary Cellular Automata</a> is one of the simplest classes of <a href="https://en.wikipedia.org/wiki/Cellular_automaton">Cellular Automata</a>.</p>\n<p>Through extremely simple rules, complex patterns can be created.</p>\n<img src="https://cloud-oz9juilm9-hack-club-bot.vercel.app/0image.png" width="512">\n<img src="https://cloud-eci1vxr8d-hack-club-bot.vercel.app/0image.png" width="512">\n<p>The rules behind Elementary Cellular Automata, or ECA, are very simple.</p>\n<p>First, set up a strip of cells, with each one having a state of either one or zero. This is the first generation. Then, start iterating through the next generation. Depending on the 3 cells above, we either set this new cell as alive or dead. This is best explained in the gif below:</p>\n<img src="https://upload.wikimedia.org/wikipedia/commons/e/e2/One-d-cellular-automate-rule-30.gif" width="512">\n<p>The rules for when to set the new cell as a one or a zero are specified by a rule code. For example, here’s how to interpret rule 30:</p>\n<p>First, convert 30 into binary digits:\n<strong>00011110</strong></p>\n<p>Each of these digits correspond to some possible state the previous that the 3 above cells can be in. For example:</p>\n<p><strong>digit: 0</strong> Since this digit is a 0, whenever the above 3 digits are [0, 0, 0] (<em>zero in binary</em>), the below cell in the next generation should be a 0</p>\n<p><strong>digit: 4</strong> Since this digit is a 1, whenever the above 3 digits are [1, 0, 0] (<em>four in binary</em>), the below cell in the next generation should be 1</p>\n<p><strong>digit 7: 1</strong> Since this digit is a 0, whenever the above 3 digits are [1, 1, 0] (<em>seven in binary</em>), the below cell in the next generation should be 0</p>\n<p>Remember, we start counting from zero in this case, not one.</p>\n<h3 id="starting-the-code">Starting the code</h3>\n<p>Create a turtle:\n<code>const t = new Turtle()</code></p>\n<p>Define the first generation, and fill it randomly:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">const width = 50\nlet genStart = Array(width).fill(0)\ngenStart = genStart.map(() => (Math.round(Math.random())))</code></pre>\n<p>You might have noticed that there are several conversions between binary and decimal in the ECA algorithm we defined. It’ll help to create a function that can do this for us:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">function toBits(num, overhead) {\n  let bits = num.toString(2)\n  return (("0".repeat(overhead - (bits.length))) + bits).split("").map((s) => {return parseInt(s)})\n}</code></pre>\n<p>The function first converts the integer into a binary string with <code>toString(2)</code>. We then add an overhead, and convert this into an integer array.</p>\n<p>Here’s what overhead does:</p>\n<ul>\n<li>Without overhead: <code>toBits(1) -> 1</code></li>\n<li>With overhead: <code>toBits(1, 8) -> 00000001</code></li>\n</ul>\n<p>This helps because we often care about the full bit sequence, not just the direct binary conversion.</p>\n<p>Next, let’s define a rule string, and convert it to an 8 bit sequence:\n<code>let rule = toBits(54, 8)</code> (Rule 54)</p>\n<p>Then, we can create an array for the generation history, starting with <code>genStart</code>:\n<code>let allGens = [genStart]</code></p>\n<p>Great! Now, it’s time to define how new generations are created.</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">function nextGen(prev) {\n  let nextGen = []</code></pre>\n<p>Iterate through the previous generation:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">  for (let i = 0; i &#x3C; prev.length; i++) {</code></pre>\n<p>Check what state it’s in:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">    for (let state = 0; state &#x3C; 8; state++) {\n      bits = toBits(state, 3)</code></pre>\n<p>We then check if the state matches, and if it does, follow the rule defined:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">      let left = (i &#x3C;= 1) ? 0 : prev[i - 1]\n      let center = prev[i]\n      let right = (i >= (prev.length - 1)) ? 0 : prev[i + 1]\n      if (left == bits[0] &#x26;&#x26; center == bits[1] &#x26;&#x26; right == bits[2]) {\n        nextGen.push(rule[8 - state - 1])\n        break\n      }\n    }\n  }\n  return nextGen\n}</code></pre>\n<p>Now, how should we draw this?\nSince the Haxidraw can’t directly render pixels, we’ll have to be a <em>bit</em> more creative with how we do this.</p>\n<p>By using the following rendering method, we can some visually interesting results:</p>\n<ul>\n<li>For each pixel rendered, check the 3 pixels above</li>\n<li>Draw a line to any above pixel if it’s filled</li>\n</ul>\n<img src="https://cloud-r14rh28dk-hack-club-bot.vercel.app/0image.png" width="512">\n<p>Here’s that in code:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">function drawGen(arr, gen) {\n  prevGen = allGens[gen]</code></pre>\n<p><code>y</code> is negative because we’re drawing top to bottom:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">  let y = -gen\n  for (let x = 0; x &#x3C; arr.length; x++) {</code></pre>\n<p>If there’s a 1 at this position, do the drawing procedure:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">    if (arr[x]) {\n      t.up()\n      t.goto([x, y])\n      t.down()</code></pre>\n<p>Check the 3 above cells, and if they’re in the 1 state, draw a line to them:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">      if (prevGen[x] == 1) t.goto([x, y + 1])\n      t.goto([x, y])\n      if (prevGen[x - 1] == 1) t.goto([x - 1, y + 1])\n      t.goto([x, y])\n      if (prevGen[x + 1] == 1) t.goto([x + 1, y + 1])\n      t.goto([x, y])\n      if (arr[x - 1] == 1) t.goto([x - 1, y])\n      t.goto([x, y])\n    }\n\n  }\n  t.up()\n  t.goto([w, -y - 1])\n}</code></pre>\n<p>Finally, iterate through the generations, and draw:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">for (let gen = 0; gen &#x3C; w; gen++) {\n  allGens.push(nextGen(allGens[gen]))\n  drawGen(allGens[gen + 1], gen)\n}\n\ndrawTurtles(t)</code></pre>\n<p>Great job! There are plenty of variations on ECAs that you can explore. Here’s a few more drawings done with the code, by setting only the center pixel as a one:</p>\n<img src="https://cloud-alkz1n9h6-hack-club-bot.vercel.app/0image.png" width="512">\n<img src="https://cloud-1w9qj075i-hack-club-bot.vercel.app/0image.png" width="512">\n<img src="https://cloud-ioqpd12zd-hack-club-bot.vercel.app/0image.png" width="512">');
const frontmatter = { "title": "Elementary Cellular Automata", "thumbnail": "https://cloud-oz9juilm9-hack-club-bot.vercel.app/0image.png", "contributors": "henrybass" };
const file = "/Users/jchen/Documents/Programming/haxidraw/new/guides/eca.md";
const url = void 0;
function rawContent() {
  return '\n### (Henry Bass, Beginner/Intermediate, 20min)\n\n[Elementary Cellular Automata](https://en.wikipedia.org/wiki/Elementary_cellular_automaton) is one of the simplest classes of [Cellular Automata](https://en.wikipedia.org/wiki/Cellular_automaton).\n\nThrough extremely simple rules, complex patterns can be created.\n\n<img src="https://cloud-oz9juilm9-hack-club-bot.vercel.app/0image.png" width="512"/>\n<img src="https://cloud-eci1vxr8d-hack-club-bot.vercel.app/0image.png" width="512"/>\n\nThe rules behind Elementary Cellular Automata, or ECA, are very simple.\n\nFirst, set up a strip of cells, with each one having a state of either one or zero. This is the first generation. Then, start iterating through the next generation. Depending on the 3 cells above, we either set this new cell as alive or dead. This is best explained in the gif below:\n\n<img src="https://upload.wikimedia.org/wikipedia/commons/e/e2/One-d-cellular-automate-rule-30.gif" width="512"/>\n\nThe rules for when to set the new cell as a one or a zero are specified by a rule code. For example, here\'s how to interpret rule 30:\n\nFirst, convert 30 into binary digits:\n**00011110**\n\nEach of these digits correspond to some possible state the previous that the 3 above cells can be in. For example:\n\n**digit: 0** Since this digit is a 0, whenever the above 3 digits are [0, 0, 0] (_zero in binary_), the below cell in the next generation should be a 0\n\n**digit: 4** Since this digit is a 1, whenever the above 3 digits are [1, 0, 0] (_four in binary_), the below cell in the next generation should be 1\n\n**digit 7: 1** Since this digit is a 0, whenever the above 3 digits are [1, 1, 0] (_seven in binary_), the below cell in the next generation should be 0\n\nRemember, we start counting from zero in this case, not one.\n\n### Starting the code\n\nCreate a turtle:\n`const t = new Turtle()`\n\nDefine the first generation, and fill it randomly:\n\n```\nconst width = 50\nlet genStart = Array(width).fill(0)\ngenStart = genStart.map(() => (Math.round(Math.random())))\n```\n\nYou might have noticed that there are several conversions between binary and decimal in the ECA algorithm we defined. It\'ll help to create a function that can do this for us:\n\n```\nfunction toBits(num, overhead) {\n  let bits = num.toString(2)\n  return (("0".repeat(overhead - (bits.length))) + bits).split("").map((s) => {return parseInt(s)})\n}\n```\n\nThe function first converts the integer into a binary string with `toString(2)`. We then add an overhead, and convert this into an integer array.\n\nHere\'s what overhead does:\n\n- Without overhead: `toBits(1) -> 1`\n- With overhead: `toBits(1, 8) -> 00000001`\n\nThis helps because we often care about the full bit sequence, not just the direct binary conversion.\n\nNext, let\'s define a rule string, and convert it to an 8 bit sequence:\n`let rule = toBits(54, 8)` (Rule 54)\n\nThen, we can create an array for the generation history, starting with `genStart`:\n`let allGens = [genStart]`\n\nGreat! Now, it\'s time to define how new generations are created.\n\n```\nfunction nextGen(prev) {\n  let nextGen = []\n```\n\nIterate through the previous generation:\n\n```\n  for (let i = 0; i < prev.length; i++) {\n```\n\nCheck what state it\'s in:\n\n```\n    for (let state = 0; state < 8; state++) {\n      bits = toBits(state, 3)\n```\n\nWe then check if the state matches, and if it does, follow the rule defined:\n\n```\n      let left = (i <= 1) ? 0 : prev[i - 1]\n      let center = prev[i]\n      let right = (i >= (prev.length - 1)) ? 0 : prev[i + 1]\n      if (left == bits[0] && center == bits[1] && right == bits[2]) {\n        nextGen.push(rule[8 - state - 1])\n        break\n      }\n    }\n  }\n  return nextGen\n}\n```\n\nNow, how should we draw this?\nSince the Haxidraw can\'t directly render pixels, we\'ll have to be a _bit_ more creative with how we do this.\n\nBy using the following rendering method, we can some visually interesting results:\n\n- For each pixel rendered, check the 3 pixels above\n- Draw a line to any above pixel if it\'s filled\n\n<img src="https://cloud-r14rh28dk-hack-club-bot.vercel.app/0image.png" width="512"/>\n\nHere\'s that in code:\n\n```\nfunction drawGen(arr, gen) {\n  prevGen = allGens[gen]\n```\n\n`y` is negative because we\'re drawing top to bottom:\n\n```\n  let y = -gen\n  for (let x = 0; x < arr.length; x++) {\n```\n\nIf there\'s a 1 at this position, do the drawing procedure:\n\n```\n    if (arr[x]) {\n      t.up()\n      t.goto([x, y])\n      t.down()\n```\n\nCheck the 3 above cells, and if they\'re in the 1 state, draw a line to them:\n\n```\n      if (prevGen[x] == 1) t.goto([x, y + 1])\n      t.goto([x, y])\n      if (prevGen[x - 1] == 1) t.goto([x - 1, y + 1])\n      t.goto([x, y])\n      if (prevGen[x + 1] == 1) t.goto([x + 1, y + 1])\n      t.goto([x, y])\n      if (arr[x - 1] == 1) t.goto([x - 1, y])\n      t.goto([x, y])\n    }\n\n  }\n  t.up()\n  t.goto([w, -y - 1])\n}\n```\n\nFinally, iterate through the generations, and draw:\n\n```\nfor (let gen = 0; gen < w; gen++) {\n  allGens.push(nextGen(allGens[gen]))\n  drawGen(allGens[gen + 1], gen)\n}\n\ndrawTurtles(t)\n```\n\nGreat job! There are plenty of variations on ECAs that you can explore. Here\'s a few more drawings done with the code, by setting only the center pixel as a one:\n\n<img src="https://cloud-alkz1n9h6-hack-club-bot.vercel.app/0image.png" width="512"/>\n<img src="https://cloud-1w9qj075i-hack-club-bot.vercel.app/0image.png" width="512"/>\n<img src="https://cloud-ioqpd12zd-hack-club-bot.vercel.app/0image.png" width="512"/>\n';
}
function compiledContent() {
  return html;
}
function getHeadings() {
  return [{ "depth": 3, "slug": "henry-bass-beginnerintermediate-20min", "text": "(Henry Bass, Beginner/Intermediate, 20min)" }, { "depth": 3, "slug": "starting-the-code", "text": "Starting the code" }];
}
async function Content() {
  const { layout, ...content } = frontmatter;
  content.file = file;
  content.url = url;
  const contentFragment = createVNode(Fragment, { "set:html": html });
  return contentFragment;
}
Content[Symbol.for("astro.needsHeadRendering")] = true;
export {
  Content,
  compiledContent,
  Content as default,
  file,
  frontmatter,
  getHeadings,
  images,
  rawContent,
  url
};
