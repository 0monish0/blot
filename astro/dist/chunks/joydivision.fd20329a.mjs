import { i as createVNode, s as spreadAttributes, F as Fragment } from "./astro.2c740cbe.mjs";
import "html-escaper";
import "cookie";
import "kleur/colors";
import "path-to-regexp";
import "mime";
import "string-width";
const images = {};
function updateImageReferences(html2) {
  return html2.replaceAll(
    /__ASTRO_IMAGE_="([^"]+)"/gm,
    (full, imagePath) => spreadAttributes({ src: images[imagePath].src, ...images[imagePath].attributes })
  );
}
const html = updateImageReferences('<p>Here’s the cover to Joy Division’s first album. The actual album is based on <a href="https://blogs.scientificamerican.com/sa-visual/pop-culture-pulsar-origin-story-of-joy-division-s-unknown-pleasures-album-cover-video/">real data</a>, but we’ll try to make a simpler version.</p>\n<img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2F4.bp.blogspot.com%2F-PkgzZc0jsVE%2FUMqYzFOzNLI%2FAAAAAAAAA3A%2FbCOqig095Lk%2Fs1600%2Fjoy_division-unknown_pleasures.jpg&#x26;f=1&#x26;nofb=1&#x26;ipt=966d8be0c759bd539613c5eaa7b35acc898bd99a43d050df6c9df643367314dc&#x26;ipo=images" width="512">\n<p>First, let’s start by noticing what we see in the image. It seems to be composed of several horizontal lines, each vertically distorted randomly. More specifically, the distortion closer to the center is more extreme, while it’s flattened farther out. There’s also another, smaller amount of random distortion evenly distributed across each line.</p>\n<p>Let’s give this a shot! First, simply declare a turtle, and draw it’s path to the screen:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">const t = new Turtle();\ndrawTurtles(t);</code></pre>\n<p>To actually get it to draw something, we can iterate through a grid, drawing horizontal lines:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">const height = 13;\nconst lineWidth = 10;\nconst lineSpacing = 0.2;\nconst dx = 0.005;\n\nfor (let line = 0; line &#x3C; height; line += lineSpacing) {\n  for (let x = -lineWidth/2; x &#x3C; lineWidth/2; x += dx) {\n    let height = line;\n    if (x == -lineWidth/2) t.up();\n    t.goto(\n      [x, height]\n    );\n    t.down();\n  }\n}</code></pre>\n<p>Each line is spaced vertically by <code>lineSpacing</code>, and composed of many line segments, each with length <code>dx</code>. We lift the turtle with <code>t.up()</code> at the start of each line to break up the path into horizontal strips.</p>\n<p>You should now be seeing a bunch of straight horizontal lines. Let’s add some randomness!</p>\n<p>A first attempt may look something like this:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">let height = Math.random();</code></pre>\n<p>You’ll quickly notice that this doesn’t look too good - the offset is <em>too</em> random. A good compromise is smooth noise. This kind of noise is random on large scales, but smooth when looked at close up. It’s good for natural-looking curves, and matches the randomness seen on the Joy Division album cover.</p>\n<p>We can call this in the Haxidraw editor with <code>noise([x, y], {octaves:n, falloff:k})</code>. The octaves dictate how intricate this noise is, and the falloff dictates how much the small scale detail should affect the final value.</p>\n<p>We don’t want pure smooth noise, and we’ll instead want to modify how we sample it a bit. Set <code>height</code> equal to <code>line + sampleNoise(x, line)</code>, and define that function:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">const baseNoiseHorizontalScale = 1.5;\nconst baseNoiseVerticalScale = 10;\nconst baseNoiseAmp = 0.1;\n\nconst addedNoiseScale = 3.2;\nconst addedNoiseAmp = 0.2;\n\nfunction sampleNoise(x, y) {\n  let baseNoise = (\n	  baseNoiseAmp *\n	  Math.pow(distFromCenter(x), 2) *\n	  noise([x * baseNoiseHorizontalScale + 14, y * baseNoiseVerticalScale], {octaves:2})\n  );\n  let addedNoise = addedNoiseAmp * noise([x * addedNoiseScale - 17, y], {octaves:2})\n  return baseNoise + addedNoise\n}</code></pre>\n<p>This function takes in a x and y, and returns some modified noise at that position. We can break the noise seen in the album cover down into 2 layers:</p>\n<ul>\n<li>Base noise: This is stronger when closer to the center, and weaker farther way. It appears to be quite smooth</li>\n<li>Added noise: This is more random, and distributed evenly across the whole image</li>\n</ul>\n<p>We define a few constants to dictate how vertically and horizontally stretched both layers of noise should be, along with a final amplitude.</p>\n<p>Notice that when defining the base noise, we use a function <code>distFromCenter</code>. We’ll have to define this as such:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">function distFromCenter(x) {\n  return lineWidth/2 - Math.abs(x)\n}</code></pre>\n<p>When incorporating this distance into the base noise, we also square the value. This simply leads to a slightly nicer looking height distribution.</p>\n<p>This looks close to the final product, but there’s still one big thing that it’s missing. Lines can overlap with each other, which really doesn’t make sense. What we need is <em>occlusion</em>. This means that lines closer to the front of the screen hide lines behind them. There’s a quick and hacky way to do this:</p>\n<ul>\n<li>Store an array corresponding to the maximum height so far in each vertical column</li>\n<li>Only draw a line when it’s higher than the previous max height</li>\n<li>If it’s the new highest, set corresponding point in the array to it’s height</li>\n</ul>\n<p>Create the array, and fill it with zeroes:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">let maxHeights = new Array(lineWidth / dx);</code></pre>\n<p>Above the line <code>if (x == -lineWidth/2) t.up();</code> in our main loop, add the following logic doing what we outlined earlier:</p>\n<pre class="language-plaintext"><code is:raw="" class="language-plaintext">    let maxHeightsIndex = Math.floor((x + lineWidth/2) / dx)\n   if (height > maxHeights[maxHeightsIndex]) {\n      t.down()\n      maxHeights[maxHeightsIndex] = height\n    } else {\n      t.up()\n    }</code></pre>\n<p>The occlusion works best when <code>dx</code> is really low.</p>\n<p>And that’s it, you’re done! When drawing the final image, you should see something like this:</p>\n<img src="https://cloud-osfrnfrf2-hack-club-bot.vercel.app/0image.png" width="512">');
const frontmatter = { "title": "Joy Division", "thumbnail": "https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2F4.bp.blogspot.com%2F-PkgzZc0jsVE%2FUMqYzFOzNLI%2FAAAAAAAAA3A%2FbCOqig095Lk%2Fs1600%2Fjoy_division-unknown_pleasures.jpg&f=1&nofb=1&ipt=966d8be0c759bd539613c5eaa7b35acc898bd99a43d050df6c9df643367314dc&ipo=images", "contributors": "henrybass" };
const file = "/Users/jchen/Documents/Programming/haxidraw/new/guides/joydivision.md";
const url = void 0;
function rawContent() {
  return "\nHere's the cover to Joy Division's first album. The actual album is based on [real data](https://blogs.scientificamerican.com/sa-visual/pop-culture-pulsar-origin-story-of-joy-division-s-unknown-pleasures-album-cover-video/), but we'll try to make a simpler version.\n\n<img src=\"https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2F4.bp.blogspot.com%2F-PkgzZc0jsVE%2FUMqYzFOzNLI%2FAAAAAAAAA3A%2FbCOqig095Lk%2Fs1600%2Fjoy_division-unknown_pleasures.jpg&f=1&nofb=1&ipt=966d8be0c759bd539613c5eaa7b35acc898bd99a43d050df6c9df643367314dc&ipo=images\" width=\"512\"/>\n\nFirst, let's start by noticing what we see in the image. It seems to be composed of several horizontal lines, each vertically distorted randomly. More specifically, the distortion closer to the center is more extreme, while it's flattened farther out. There's also another, smaller amount of random distortion evenly distributed across each line.\n\nLet's give this a shot! First, simply declare a turtle, and draw it's path to the screen:\n\n```\nconst t = new Turtle();\ndrawTurtles(t);\n```\n\nTo actually get it to draw something, we can iterate through a grid, drawing horizontal lines:\n\n```\nconst height = 13;\nconst lineWidth = 10;\nconst lineSpacing = 0.2;\nconst dx = 0.005;\n\nfor (let line = 0; line < height; line += lineSpacing) {\n  for (let x = -lineWidth/2; x < lineWidth/2; x += dx) {\n    let height = line;\n    if (x == -lineWidth/2) t.up();\n    t.goto(\n      [x, height]\n    );\n    t.down();\n  }\n}\n```\n\nEach line is spaced vertically by `lineSpacing`, and composed of many line segments, each with length `dx`. We lift the turtle with `t.up()` at the start of each line to break up the path into horizontal strips.\n\nYou should now be seeing a bunch of straight horizontal lines. Let's add some randomness!\n\nA first attempt may look something like this:\n\n```\nlet height = Math.random();\n```\n\nYou'll quickly notice that this doesn't look too good - the offset is _too_ random. A good compromise is smooth noise. This kind of noise is random on large scales, but smooth when looked at close up. It's good for natural-looking curves, and matches the randomness seen on the Joy Division album cover.\n\nWe can call this in the Haxidraw editor with `noise([x, y], {octaves:n, falloff:k})`. The octaves dictate how intricate this noise is, and the falloff dictates how much the small scale detail should affect the final value.\n\nWe don't want pure smooth noise, and we'll instead want to modify how we sample it a bit. Set `height` equal to `line + sampleNoise(x, line)`, and define that function:\n\n```\nconst baseNoiseHorizontalScale = 1.5;\nconst baseNoiseVerticalScale = 10;\nconst baseNoiseAmp = 0.1;\n\nconst addedNoiseScale = 3.2;\nconst addedNoiseAmp = 0.2;\n\nfunction sampleNoise(x, y) {\n  let baseNoise = (\n	  baseNoiseAmp *\n	  Math.pow(distFromCenter(x), 2) *\n	  noise([x * baseNoiseHorizontalScale + 14, y * baseNoiseVerticalScale], {octaves:2})\n  );\n  let addedNoise = addedNoiseAmp * noise([x * addedNoiseScale - 17, y], {octaves:2})\n  return baseNoise + addedNoise\n}\n```\n\nThis function takes in a x and y, and returns some modified noise at that position. We can break the noise seen in the album cover down into 2 layers:\n\n- Base noise: This is stronger when closer to the center, and weaker farther way. It appears to be quite smooth\n- Added noise: This is more random, and distributed evenly across the whole image\n\nWe define a few constants to dictate how vertically and horizontally stretched both layers of noise should be, along with a final amplitude.\n\nNotice that when defining the base noise, we use a function `distFromCenter`. We'll have to define this as such:\n\n```\nfunction distFromCenter(x) {\n  return lineWidth/2 - Math.abs(x)\n}\n```\n\nWhen incorporating this distance into the base noise, we also square the value. This simply leads to a slightly nicer looking height distribution.\n\nThis looks close to the final product, but there's still one big thing that it's missing. Lines can overlap with each other, which really doesn't make sense. What we need is _occlusion_. This means that lines closer to the front of the screen hide lines behind them. There's a quick and hacky way to do this:\n\n- Store an array corresponding to the maximum height so far in each vertical column\n- Only draw a line when it's higher than the previous max height\n- If it's the new highest, set corresponding point in the array to it's height\n\nCreate the array, and fill it with zeroes:\n\n```\nlet maxHeights = new Array(lineWidth / dx);\n```\n\nAbove the line `if (x == -lineWidth/2) t.up();` in our main loop, add the following logic doing what we outlined earlier:\n\n```\n    let maxHeightsIndex = Math.floor((x + lineWidth/2) / dx)\n   if (height > maxHeights[maxHeightsIndex]) {\n      t.down()\n      maxHeights[maxHeightsIndex] = height\n    } else {\n      t.up()\n    }\n```\n\nThe occlusion works best when `dx` is really low.\n\nAnd that's it, you're done! When drawing the final image, you should see something like this:\n\n<img src=\"https://cloud-osfrnfrf2-hack-club-bot.vercel.app/0image.png\" width=\"512\"/>\n";
}
function compiledContent() {
  return html;
}
function getHeadings() {
  return [];
}
async function Content() {
  const { layout, ...content } = frontmatter;
  content.file = file;
  content.url = url;
  const contentFragment = createVNode(Fragment, { "set:html": html });
  return contentFragment;
}
Content[Symbol.for("astro.needsHeadRendering")] = true;
export {
  Content,
  compiledContent,
  Content as default,
  file,
  frontmatter,
  getHeadings,
  images,
  rawContent,
  url
};
